			Last revised 20-Jul-16

			    Problem Set 3

		 Harvard Extension School CSCI E-95:
	    Compiler Design and Implementation - Fall 2016

		   Due: Midnight on October 9, 2016

1. (100 Points) Using your lexer from Problem Set 1 and your YACC or
Bison parser from Problem Set 2, develop a complete symbol table
management system.

As your compiler reads the input program being compiled, it should
generate a symbol table in memory which represents all identifiers in
the program.  Each identifier needs to be associated with its
appropriate type data structure that describes the declared type of
the identifier.  This type data structure should be of the form
discussed in class -- it is the data structure shown in the "Type
Checking" slides on the class web site
(http://sites.fas.harvard.edu/~libe295/spring2015/slides/Type%20Checking.pdf).
All references to identifiers in the abstract syntax tree should be
replaced with pointers into the symbol table.  As in Problem Set 2,
all statements, expressions, and other elements from the grammar
should be replaced by data structures in the abstract syntax tree.

Keep in mind that your compiler needs to produce multiple symbol
tables: one for each overloading class and one for each scope.  Our
overloading classes are: (1) statement labels and (2) "other names"
(see Harbison & Steele, page 78, table 4-2).  You will have a possible
symbol table for statement labels for each procedure.  You will have a
possible symbol table for "other names" at file scope, at each
procedure scope, and at each block scope (see Harbison & Steele, page
75, table 4-1).

Errors should be emitted for identifiers that are defined more than
once in the same overloading class in the same scope and also for
references to identifiers that are not declared in that scope or in
any enclosing scope.

As part of this problem set, your compiler needs to ensure that a
procedure prototype declaration and a procedure definition for the
same procedure have the same number of parameters, identical parameter
types, and identical return types.  In addition, all declarations must
be checked to verify that they are for legal types.  For example,
functions are not allowed to return an array type (see Harbison &
Steele at the bottom on page 101 and the top of page 102).  Also,
every parameter must be named in a procedure definition.

All arithmetic types should be converted into canonical types.  For
example, "int," "signed int," and "signed" should all be represented
by the same base type.

For array declarations, the bounds of arrays are allowed to be
constant expressions.  These should be evaluated to an integer
constant as part of this problem set.  You should check that array
indexes are specified when they are required (see Harbison & Steele,
pages 98-99 on Incomplete Array Types).

There are at least two approaches to dealing with statement labels:

Approach 1: When you see a statement label defined (as in "label:")
and the label is not already in the appropriate statement label symbol
table, add it to that statement label symbol table with a "defined"
attribute.  When you see a statement label defined and the label is
already in the symbol table, if the attribute is "defined," then the
label is multiply defined (emit an error message).  If the attribute
is "referenced," then change the attribute to "defined."  When you see
a "goto" statement, if the label referred to in the goto is already in
the symbol table, do nothing.  If the label referred to in the goto is
not already in the symbol table, add it to the appropriate statement
label symbol table with a "referenced" attribute.  After each symbol
table is fully built, make a pass over the symbol table to ensure that
all labels in the statement label symbol table are tagged as defined.
Any label tagged as "referenced" is a reference to an undefined label
(emit an error message).

Approach 2: When you see a statement label defined (as in "label:"),
add it to the appropriate statement label symbol table.  If the label
is already in the statement label symbol table, then the label is
multiply defined (emit an error message).  No information needs to be
associated with the statement label in the symbol table.  When you see
a "goto" statement, you can remember the label as an uninterpreted
string.  After the symbol tables are fully built, make a pass over the
abstract syntax tree to ensure that all references to labels in goto
statements are defined in the appropriate symbol table.  Error
messages should be emitted for any references to undefined labels.
You don't need to resolve the references to statement labels in goto
statements to point into the symbol table.

More information will be furnished later about how to generate code
for statement label definitions and references.  Leave both the
statement label definitions and the goto statements in the abstract
syntax tree.

In addition to pretty printing the parse tree from Problem Set 2, your
compiler should include a facility that dumps the symbol tables in a
meaningful way when the end of the input program has been reached.
All references to identifiers should be tagged in such a way as to
indicate in which symbol table that identifier is declared.  This
should be accomplished by inserting a comment that includes a specific
symbol table tag after each identifier is emitted in the pretty print
of the parse tree.

Remember the solution that you turn in should include a demonstration
that your program works and has been tested.  Thus, the test programs
you use as input and the output that your compiler produces should be
included with your other files.

As always, you should use "git" to submit completed work and tag it
with ps3-submit.
